using System.Net.Http.Json;
using System.Text.Json;
using System.Text.Json.Serialization;
using BaseScanner.Analyzers.Dependencies.Models;

namespace BaseScanner.Analyzers.Dependencies;

/// <summary>
/// Interface for vulnerability database access
/// </summary>
public interface IVulnerabilityDatabase
{
    Task<List<SecurityAdvisory>> GetAdvisoriesAsync(string packageId, string version);
    Task<PackageMetadata?> GetPackageMetadataAsync(string packageId);
}

/// <summary>
/// Client for NuGet vulnerability and package metadata APIs
/// </summary>
public class NuGetVulnerabilityClient : IVulnerabilityDatabase, IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly Dictionary<string, List<SecurityAdvisory>> _advisoryCache = new();
    private readonly Dictionary<string, PackageMetadata> _metadataCache = new();
    private readonly SemaphoreSlim _cacheLock = new(1, 1);

    // NuGet API endpoints
    private const string NuGetVulnerabilityIndexUrl = "https://api.nuget.org/v3/vulnerabilities/index.json";
    private const string NuGetRegistrationBase = "https://api.nuget.org/v3/registration5-semver1/";
    private const string GitHubAdvisoryApi = "https://api.github.com/advisories";

    // Local vulnerability database (embedded for offline use)
    private static readonly Dictionary<string, List<KnownVulnerability>> KnownVulnerabilities = new()
    {
        ["Newtonsoft.Json"] = new()
        {
            new("CVE-2024-21907", "GHSA-5crp-9r3c-p9vr", "High", 7.5, "< 13.0.1",
                "Improper Handling of Exceptional Conditions", "13.0.1")
        },
        ["System.Text.Json"] = new()
        {
            new("CVE-2024-30105", null, "High", 7.5, "< 8.0.4",
                "Denial of Service vulnerability", "8.0.4")
        },
        ["Microsoft.Data.SqlClient"] = new()
        {
            new("CVE-2024-0056", "GHSA-98g6-xh36-x2p7", "High", 8.7, "< 5.1.4",
                "SQL Injection vulnerability", "5.1.4")
        },
        ["System.Security.Cryptography.Xml"] = new()
        {
            new("CVE-2024-21404", null, "High", 7.5, "< 8.0.1",
                "Denial of Service vulnerability", "8.0.1")
        },
        ["Microsoft.AspNetCore.Components"] = new()
        {
            new("CVE-2024-21386", null, "High", 7.5, "< 8.0.2",
                "Security Feature Bypass", "8.0.2")
        },
        ["log4net"] = new()
        {
            new("CVE-2018-1285", "GHSA-2cwj-8chv-gpvv", "Critical", 9.8, "< 2.0.10",
                "XXE vulnerability in configuration parsing", "2.0.10")
        },
        ["jQuery"] = new()
        {
            new("CVE-2020-11022", "GHSA-gxr4-xjj5-5px2", "Medium", 6.1, "< 3.5.0",
                "Cross-site Scripting (XSS) vulnerability", "3.5.0")
        },
        ["System.Drawing.Common"] = new()
        {
            new("CVE-2021-24112", null, "Critical", 9.8, "< 5.0.3",
                "Remote Code Execution vulnerability", "5.0.3")
        },
        ["Microsoft.IdentityModel.Tokens"] = new()
        {
            new("CVE-2024-21319", null, "Medium", 6.8, "< 7.1.2",
                "Denial of Service vulnerability", "7.1.2")
        },
        ["RestSharp"] = new()
        {
            new("CVE-2024-45302", "GHSA-4rr6-2v9v-wcpc", "High", 7.5, "< 112.0.0",
                "CRLF Injection vulnerability", "112.0.0")
        }
    };

    public NuGetVulnerabilityClient()
    {
        _httpClient = new HttpClient();
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "BaseScanner/1.0");
        _httpClient.Timeout = TimeSpan.FromSeconds(30);
    }

    public async Task<List<SecurityAdvisory>> GetAdvisoriesAsync(string packageId, string version)
    {
        var cacheKey = $"{packageId}@{version}";

        await _cacheLock.WaitAsync();
        try
        {
            if (_advisoryCache.TryGetValue(cacheKey, out var cached))
                return cached;
        }
        finally
        {
            _cacheLock.Release();
        }

        var advisories = new List<SecurityAdvisory>();

        // Check local known vulnerabilities first
        if (KnownVulnerabilities.TryGetValue(packageId, out var known))
        {
            foreach (var vuln in known)
            {
                if (IsVersionAffected(version, vuln.AffectedVersions))
                {
                    advisories.Add(new SecurityAdvisory
                    {
                        Id = vuln.CveId ?? vuln.GhsaId ?? Guid.NewGuid().ToString(),
                        CveId = vuln.CveId,
                        GhsaId = vuln.GhsaId,
                        PackageId = packageId,
                        Severity = vuln.Severity,
                        CvssScore = vuln.CvssScore,
                        Description = vuln.Description,
                        FixedInVersion = vuln.FixedVersion,
                        AffectedVersions = new List<string> { vuln.AffectedVersions },
                        AdvisoryUrl = vuln.CveId != null
                            ? $"https://nvd.nist.gov/vuln/detail/{vuln.CveId}"
                            : vuln.GhsaId != null
                                ? $"https://github.com/advisories/{vuln.GhsaId}"
                                : null,
                        PublishedDate = null,
                        Cwe = new List<string>()
                    });
                }
            }
        }

        // Try to fetch from NuGet vulnerability API
        try
        {
            var nugetAdvisories = await FetchNuGetVulnerabilitiesAsync(packageId, version);
            advisories.AddRange(nugetAdvisories);
        }
        catch (Exception)
        {
            // Silently continue with local database if API fails
        }

        // Deduplicate by CVE/GHSA ID
        advisories = advisories
            .GroupBy(a => a.CveId ?? a.GhsaId ?? a.Id)
            .Select(g => g.First())
            .ToList();

        await _cacheLock.WaitAsync();
        try
        {
            _advisoryCache[cacheKey] = advisories;
        }
        finally
        {
            _cacheLock.Release();
        }

        return advisories;
    }

    public async Task<PackageMetadata?> GetPackageMetadataAsync(string packageId)
    {
        await _cacheLock.WaitAsync();
        try
        {
            if (_metadataCache.TryGetValue(packageId, out var cached))
                return cached;
        }
        finally
        {
            _cacheLock.Release();
        }

        try
        {
            var registrationUrl = $"{NuGetRegistrationBase}{packageId.ToLowerInvariant()}/index.json";
            var response = await _httpClient.GetAsync(registrationUrl);

            if (!response.IsSuccessStatusCode)
                return null;

            var json = await response.Content.ReadAsStringAsync();
            var registration = JsonSerializer.Deserialize<NuGetRegistration>(json, JsonOptions);

            if (registration?.Items == null || registration.Items.Count == 0)
                return null;

            var allVersions = new List<string>();
            string? latestVersion = null;
            string? latestStableVersion = null;
            DateTime? lastUpdated = null;
            bool isDeprecated = false;
            string? deprecationMessage = null;
            string? alternativePackage = null;

            foreach (var page in registration.Items)
            {
                var items = page.Items ?? new List<NuGetCatalogEntry>();

                // If items is empty, we need to fetch the page
                if (items.Count == 0 && !string.IsNullOrEmpty(page.Id))
                {
                    try
                    {
                        var pageResponse = await _httpClient.GetAsync(page.Id);
                        if (pageResponse.IsSuccessStatusCode)
                        {
                            var pageJson = await pageResponse.Content.ReadAsStringAsync();
                            var pageData = JsonSerializer.Deserialize<NuGetRegistrationPage>(pageJson, JsonOptions);
                            items = pageData?.Items ?? new List<NuGetCatalogEntry>();
                        }
                    }
                    catch
                    {
                        continue;
                    }
                }

                foreach (var item in items)
                {
                    var entry = item.CatalogEntry ?? item;
                    if (entry.Version == null) continue;

                    allVersions.Add(entry.Version);

                    var isPrerelease = entry.Version.Contains("-");
                    var published = entry.Published;

                    if (lastUpdated == null || (published != null && published > lastUpdated))
                    {
                        lastUpdated = published;
                        latestVersion = entry.Version;
                    }

                    if (!isPrerelease && (latestStableVersion == null ||
                        CompareVersions(entry.Version, latestStableVersion) > 0))
                    {
                        latestStableVersion = entry.Version;
                    }

                    // Check for deprecation
                    if (entry.Deprecation != null)
                    {
                        isDeprecated = true;
                        deprecationMessage = entry.Deprecation.Message;
                        alternativePackage = entry.Deprecation.AlternatePackage?.Id;
                    }
                }
            }

            var metadata = new PackageMetadata
            {
                PackageId = packageId,
                LatestVersion = latestVersion ?? "unknown",
                LatestStableVersion = latestStableVersion,
                IsDeprecated = isDeprecated,
                DeprecationMessage = deprecationMessage,
                AlternativePackage = alternativePackage,
                LastUpdated = lastUpdated,
                AllVersions = allVersions.OrderByDescending(v => v).Take(20).ToList()
            };

            await _cacheLock.WaitAsync();
            try
            {
                _metadataCache[packageId] = metadata;
            }
            finally
            {
                _cacheLock.Release();
            }

            return metadata;
        }
        catch (Exception)
        {
            return null;
        }
    }

    private async Task<List<SecurityAdvisory>> FetchNuGetVulnerabilitiesAsync(string packageId, string version)
    {
        var advisories = new List<SecurityAdvisory>();

        try
        {
            // Fetch the vulnerability index
            var indexResponse = await _httpClient.GetAsync(NuGetVulnerabilityIndexUrl);
            if (!indexResponse.IsSuccessStatusCode)
                return advisories;

            var indexJson = await indexResponse.Content.ReadAsStringAsync();
            var index = JsonSerializer.Deserialize<NuGetVulnerabilityIndex>(indexJson, JsonOptions);

            if (index?.Pages == null)
                return advisories;

            // Check each vulnerability page
            foreach (var pageUrl in index.Pages.Take(5)) // Limit to recent pages
            {
                try
                {
                    var pageResponse = await _httpClient.GetAsync(pageUrl);
                    if (!pageResponse.IsSuccessStatusCode)
                        continue;

                    var pageJson = await pageResponse.Content.ReadAsStringAsync();
                    var vulnerabilities = JsonSerializer.Deserialize<Dictionary<string, List<NuGetVulnerability>>>(pageJson, JsonOptions);

                    if (vulnerabilities == null)
                        continue;

                    // Check if this package has vulnerabilities
                    if (vulnerabilities.TryGetValue(packageId.ToLowerInvariant(), out var packageVulns))
                    {
                        foreach (var vuln in packageVulns)
                        {
                            if (IsVersionInRange(version, vuln.Versions))
                            {
                                advisories.Add(new SecurityAdvisory
                                {
                                    Id = vuln.AdvisoryUrl ?? Guid.NewGuid().ToString(),
                                    CveId = null,
                                    GhsaId = ExtractGhsaFromUrl(vuln.AdvisoryUrl),
                                    PackageId = packageId,
                                    Severity = MapNuGetSeverity(vuln.Severity),
                                    CvssScore = vuln.Severity switch
                                    {
                                        0 => 3.0,  // Low
                                        1 => 5.5,  // Medium
                                        2 => 7.5,  // High
                                        3 => 9.5,  // Critical
                                        _ => 5.0
                                    },
                                    Description = $"Vulnerability in {packageId}",
                                    FixedInVersion = null,
                                    AffectedVersions = vuln.Versions.Split(',').ToList(),
                                    AdvisoryUrl = vuln.AdvisoryUrl,
                                    PublishedDate = null,
                                    Cwe = new List<string>()
                                });
                            }
                        }
                    }
                }
                catch
                {
                    continue;
                }
            }
        }
        catch
        {
            // Return whatever we have
        }

        return advisories;
    }

    private static bool IsVersionAffected(string installedVersion, string affectedRange)
    {
        // Simple version range parsing: "< X.Y.Z" format
        if (affectedRange.StartsWith("< "))
        {
            var maxVersion = affectedRange.Substring(2).Trim();
            return CompareVersions(installedVersion, maxVersion) < 0;
        }

        if (affectedRange.StartsWith("<= "))
        {
            var maxVersion = affectedRange.Substring(3).Trim();
            return CompareVersions(installedVersion, maxVersion) <= 0;
        }

        if (affectedRange.Contains(" - "))
        {
            var parts = affectedRange.Split(" - ");
            if (parts.Length == 2)
            {
                return CompareVersions(installedVersion, parts[0].Trim()) >= 0 &&
                       CompareVersions(installedVersion, parts[1].Trim()) <= 0;
            }
        }

        return affectedRange == installedVersion;
    }

    private static bool IsVersionInRange(string version, string rangeSpec)
    {
        // NuGet version range format: [1.0.0, 2.0.0) or (,1.0.0]
        try
        {
            foreach (var range in rangeSpec.Split(','))
            {
                var trimmed = range.Trim();
                if (string.IsNullOrEmpty(trimmed))
                    continue;

                // Handle simple comparisons
                if (trimmed.StartsWith("[") || trimmed.StartsWith("("))
                {
                    // Interval notation
                    var inclusive = trimmed.StartsWith("[");
                    var versionPart = trimmed.TrimStart('[', '(').TrimEnd(']', ')');

                    if (string.IsNullOrEmpty(versionPart))
                        continue;

                    var comparison = CompareVersions(version, versionPart);
                    if (inclusive ? comparison >= 0 : comparison > 0)
                        return true;
                }
                else
                {
                    // Direct version match
                    if (version.StartsWith(trimmed) || trimmed.StartsWith(version))
                        return true;
                }
            }
        }
        catch
        {
            // If parsing fails, assume not affected
        }

        return false;
    }

    private static int CompareVersions(string v1, string v2)
    {
        try
        {
            // Remove prerelease suffixes for comparison
            var v1Clean = v1.Split('-')[0];
            var v2Clean = v2.Split('-')[0];

            var parts1 = v1Clean.Split('.').Select(p => int.TryParse(p, out var n) ? n : 0).ToArray();
            var parts2 = v2Clean.Split('.').Select(p => int.TryParse(p, out var n) ? n : 0).ToArray();

            var maxLen = Math.Max(parts1.Length, parts2.Length);

            for (int i = 0; i < maxLen; i++)
            {
                var p1 = i < parts1.Length ? parts1[i] : 0;
                var p2 = i < parts2.Length ? parts2[i] : 0;

                if (p1 != p2)
                    return p1.CompareTo(p2);
            }

            return 0;
        }
        catch
        {
            return string.Compare(v1, v2, StringComparison.OrdinalIgnoreCase);
        }
    }

    private static string MapNuGetSeverity(int severity)
    {
        return severity switch
        {
            0 => VulnerabilitySeverity.Low,
            1 => VulnerabilitySeverity.Medium,
            2 => VulnerabilitySeverity.High,
            3 => VulnerabilitySeverity.Critical,
            _ => VulnerabilitySeverity.Medium
        };
    }

    private static string? ExtractGhsaFromUrl(string? url)
    {
        if (string.IsNullOrEmpty(url))
            return null;

        if (url.Contains("github.com/advisories/"))
        {
            var parts = url.Split('/');
            return parts.LastOrDefault();
        }

        return null;
    }

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    public void Dispose()
    {
        _httpClient.Dispose();
        _cacheLock.Dispose();
    }

    // Internal record for known vulnerabilities
    private record KnownVulnerability(
        string? CveId,
        string? GhsaId,
        string Severity,
        double CvssScore,
        string AffectedVersions,
        string Description,
        string? FixedVersion);

    // JSON models for NuGet API
    private class NuGetVulnerabilityIndex
    {
        [JsonPropertyName("pages")]
        public List<string>? Pages { get; set; }
    }

    private class NuGetVulnerability
    {
        [JsonPropertyName("severity")]
        public int Severity { get; set; }

        [JsonPropertyName("advisoryUrl")]
        public string? AdvisoryUrl { get; set; }

        [JsonPropertyName("versions")]
        public string Versions { get; set; } = "";
    }

    private class NuGetRegistration
    {
        [JsonPropertyName("items")]
        public List<NuGetRegistrationPage>? Items { get; set; }
    }

    private class NuGetRegistrationPage
    {
        [JsonPropertyName("@id")]
        public string? Id { get; set; }

        [JsonPropertyName("items")]
        public List<NuGetCatalogEntry>? Items { get; set; }
    }

    private class NuGetCatalogEntry
    {
        [JsonPropertyName("catalogEntry")]
        public NuGetCatalogEntry? CatalogEntry { get; set; }

        [JsonPropertyName("version")]
        public string? Version { get; set; }

        [JsonPropertyName("published")]
        public DateTime? Published { get; set; }

        [JsonPropertyName("deprecation")]
        public NuGetDeprecation? Deprecation { get; set; }
    }

    private class NuGetDeprecation
    {
        [JsonPropertyName("message")]
        public string? Message { get; set; }

        [JsonPropertyName("alternatePackage")]
        public NuGetAlternatePackage? AlternatePackage { get; set; }
    }

    private class NuGetAlternatePackage
    {
        [JsonPropertyName("id")]
        public string? Id { get; set; }
    }
}
