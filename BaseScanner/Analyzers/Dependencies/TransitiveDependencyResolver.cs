using System.Text.Json;
using System.Text.Json.Serialization;
using BaseScanner.Analyzers.Dependencies.Models;

namespace BaseScanner.Analyzers.Dependencies;

/// <summary>
/// Resolves transitive dependencies from NuGet assets files and lock files.
/// </summary>
public class TransitiveDependencyResolver
{
    private readonly Dictionary<string, List<string>> _dependencyCache = new();

    /// <summary>
    /// Resolves transitive dependencies for a project.
    /// </summary>
    /// <param name="projectPath">Path to the .csproj file</param>
    /// <param name="directPackages">Direct package references from the project</param>
    /// <returns>Dictionary mapping package ID to its transitive dependencies</returns>
    public async Task<Dictionary<string, List<string>>> ResolveTransitiveDependenciesAsync(
        string projectPath,
        List<PackageReference> directPackages)
    {
        var result = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

        // Try to read from project.assets.json (generated by NuGet restore)
        var assetsPath = FindAssetsFile(projectPath);
        if (assetsPath != null && File.Exists(assetsPath))
        {
            try
            {
                var dependencies = await ParseAssetsFileAsync(assetsPath);
                foreach (var (packageId, deps) in dependencies)
                {
                    result[packageId] = deps;
                }
            }
            catch
            {
                // Fall back to packages.lock.json
            }
        }

        // Try packages.lock.json if assets file didn't work
        if (result.Count == 0)
        {
            var lockPath = FindLockFile(projectPath);
            if (lockPath != null && File.Exists(lockPath))
            {
                try
                {
                    var dependencies = await ParseLockFileAsync(lockPath);
                    foreach (var (packageId, deps) in dependencies)
                    {
                        result[packageId] = deps;
                    }
                }
                catch
                {
                    // Continue without transitive dependency resolution
                }
            }
        }

        // Build the transitive tree from direct packages
        var transitiveTree = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
        foreach (var package in directPackages)
        {
            var allTransitive = GetAllTransitiveDependencies(package.PackageId, result, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
            transitiveTree[package.PackageId] = allTransitive;
        }

        return transitiveTree;
    }

    /// <summary>
    /// Gets all packages in the dependency tree (direct + transitive).
    /// </summary>
    public List<PackageReference> GetAllPackages(
        List<PackageReference> directPackages,
        Dictionary<string, List<string>> transitiveTree,
        Dictionary<string, string> packageVersions)
    {
        var allPackages = new Dictionary<string, PackageReference>(StringComparer.OrdinalIgnoreCase);

        // Add direct packages
        foreach (var package in directPackages)
        {
            allPackages[package.PackageId] = package;
        }

        // Add transitive packages
        foreach (var (directId, transitiveDeps) in transitiveTree)
        {
            foreach (var transitiveId in transitiveDeps)
            {
                if (!allPackages.ContainsKey(transitiveId))
                {
                    var version = packageVersions.GetValueOrDefault(transitiveId, "unknown");
                    allPackages[transitiveId] = new PackageReference
                    {
                        PackageId = transitiveId,
                        Version = version,
                        IsDirectReference = false,
                        ProjectPath = directPackages.FirstOrDefault()?.ProjectPath
                    };
                }
            }
        }

        return allPackages.Values.ToList();
    }

    /// <summary>
    /// Finds the transitive source for a package (which direct package brought it in).
    /// </summary>
    public string? FindTransitiveSource(
        string packageId,
        List<PackageReference> directPackages,
        Dictionary<string, List<string>> transitiveTree)
    {
        foreach (var direct in directPackages)
        {
            if (transitiveTree.TryGetValue(direct.PackageId, out var transitive))
            {
                if (transitive.Contains(packageId, StringComparer.OrdinalIgnoreCase))
                {
                    return direct.PackageId;
                }
            }
        }

        return null;
    }

    private string? FindAssetsFile(string projectPath)
    {
        var projectDir = Path.GetDirectoryName(projectPath);
        if (projectDir == null) return null;

        // Standard location: obj/project.assets.json
        var assetsPath = Path.Combine(projectDir, "obj", "project.assets.json");
        if (File.Exists(assetsPath))
            return assetsPath;

        // Try Debug/Release configurations
        foreach (var config in new[] { "Debug", "Release" })
        {
            foreach (var framework in new[] { "net9.0", "net8.0", "net7.0", "net6.0", "netstandard2.1", "netstandard2.0" })
            {
                assetsPath = Path.Combine(projectDir, "obj", config, framework, "project.assets.json");
                if (File.Exists(assetsPath))
                    return assetsPath;
            }
        }

        return null;
    }

    private string? FindLockFile(string projectPath)
    {
        var projectDir = Path.GetDirectoryName(projectPath);
        if (projectDir == null) return null;

        var lockPath = Path.Combine(projectDir, "packages.lock.json");
        return File.Exists(lockPath) ? lockPath : null;
    }

    private async Task<Dictionary<string, List<string>>> ParseAssetsFileAsync(string assetsPath)
    {
        var result = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

        try
        {
            var json = await File.ReadAllTextAsync(assetsPath);
            var assets = JsonSerializer.Deserialize<NuGetAssetsFile>(json, JsonOptions);

            if (assets?.Targets == null)
                return result;

            // Get the first target framework (usually the main one)
            foreach (var (_, packages) in assets.Targets)
            {
                foreach (var (packageKey, packageInfo) in packages)
                {
                    var packageId = ExtractPackageId(packageKey);
                    var dependencies = new List<string>();

                    if (packageInfo.Dependencies != null)
                    {
                        dependencies.AddRange(packageInfo.Dependencies.Keys);
                    }

                    result[packageId] = dependencies;

                    // Cache version information
                    var version = ExtractVersion(packageKey);
                    if (!string.IsNullOrEmpty(version))
                    {
                        _dependencyCache[$"{packageId}@version"] = new List<string> { version };
                    }
                }

                break; // Only process first target framework
            }
        }
        catch
        {
            // Return empty result on parse failure
        }

        return result;
    }

    private async Task<Dictionary<string, List<string>>> ParseLockFileAsync(string lockPath)
    {
        var result = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

        try
        {
            var json = await File.ReadAllTextAsync(lockPath);
            var lockFile = JsonSerializer.Deserialize<NuGetLockFile>(json, JsonOptions);

            if (lockFile?.Dependencies == null)
                return result;

            // Parse dependencies from each framework
            foreach (var (_, frameworkDeps) in lockFile.Dependencies)
            {
                foreach (var (packageId, depInfo) in frameworkDeps)
                {
                    var dependencies = new List<string>();

                    if (depInfo.Dependencies != null)
                    {
                        dependencies.AddRange(depInfo.Dependencies.Keys);
                    }

                    if (!result.ContainsKey(packageId))
                    {
                        result[packageId] = dependencies;
                    }

                    // Store version
                    if (!string.IsNullOrEmpty(depInfo.Resolved))
                    {
                        _dependencyCache[$"{packageId}@version"] = new List<string> { depInfo.Resolved };
                    }
                }
            }
        }
        catch
        {
            // Return empty result on parse failure
        }

        return result;
    }

    /// <summary>
    /// Gets package versions from cached data.
    /// </summary>
    public Dictionary<string, string> GetPackageVersions()
    {
        var versions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        foreach (var (key, values) in _dependencyCache)
        {
            if (key.EndsWith("@version") && values.Count > 0)
            {
                var packageId = key.Replace("@version", "");
                versions[packageId] = values[0];
            }
        }

        return versions;
    }

    private List<string> GetAllTransitiveDependencies(
        string packageId,
        Dictionary<string, List<string>> dependencyGraph,
        HashSet<string> visited)
    {
        var result = new List<string>();

        if (!dependencyGraph.TryGetValue(packageId, out var directDeps))
            return result;

        foreach (var dep in directDeps)
        {
            if (visited.Add(dep))
            {
                result.Add(dep);
                result.AddRange(GetAllTransitiveDependencies(dep, dependencyGraph, visited));
            }
        }

        return result;
    }

    private static string ExtractPackageId(string packageKey)
    {
        // Format: "PackageId/Version"
        var slashIndex = packageKey.IndexOf('/');
        return slashIndex > 0 ? packageKey.Substring(0, slashIndex) : packageKey;
    }

    private static string ExtractVersion(string packageKey)
    {
        // Format: "PackageId/Version"
        var slashIndex = packageKey.IndexOf('/');
        return slashIndex > 0 ? packageKey.Substring(slashIndex + 1) : "";
    }

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    // NuGet assets file models
    private class NuGetAssetsFile
    {
        [JsonPropertyName("targets")]
        public Dictionary<string, Dictionary<string, NuGetPackageInfo>>? Targets { get; set; }

        [JsonPropertyName("libraries")]
        public Dictionary<string, NuGetLibraryInfo>? Libraries { get; set; }
    }

    private class NuGetPackageInfo
    {
        [JsonPropertyName("type")]
        public string? Type { get; set; }

        [JsonPropertyName("dependencies")]
        public Dictionary<string, string>? Dependencies { get; set; }
    }

    private class NuGetLibraryInfo
    {
        [JsonPropertyName("type")]
        public string? Type { get; set; }

        [JsonPropertyName("path")]
        public string? Path { get; set; }
    }

    // NuGet lock file models
    private class NuGetLockFile
    {
        [JsonPropertyName("version")]
        public int Version { get; set; }

        [JsonPropertyName("dependencies")]
        public Dictionary<string, Dictionary<string, NuGetLockDependency>>? Dependencies { get; set; }
    }

    private class NuGetLockDependency
    {
        [JsonPropertyName("type")]
        public string? Type { get; set; }

        [JsonPropertyName("resolved")]
        public string? Resolved { get; set; }

        [JsonPropertyName("contentHash")]
        public string? ContentHash { get; set; }

        [JsonPropertyName("dependencies")]
        public Dictionary<string, string>? Dependencies { get; set; }
    }
}
