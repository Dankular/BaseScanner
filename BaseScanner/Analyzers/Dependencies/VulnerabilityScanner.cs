using BaseScanner.Analyzers.Dependencies.Models;

namespace BaseScanner.Analyzers.Dependencies;

/// <summary>
/// Main vulnerability scanner that coordinates package analysis, vulnerability detection,
/// outdated package checks, and deprecation detection.
/// </summary>
public class VulnerabilityScanner : IDisposable
{
    private readonly PackageAnalyzer _packageAnalyzer;
    private readonly NuGetVulnerabilityClient _vulnerabilityClient;
    private readonly TransitiveDependencyResolver _transitiveResolver;

    public VulnerabilityScanner()
    {
        _packageAnalyzer = new PackageAnalyzer();
        _vulnerabilityClient = new NuGetVulnerabilityClient();
        _transitiveResolver = new TransitiveDependencyResolver();
    }

    /// <summary>
    /// Scans a project or solution for package vulnerabilities.
    /// </summary>
    /// <param name="path">Path to solution, project, or directory</param>
    /// <returns>Complete vulnerability analysis result</returns>
    public async Task<VulnerabilityResult> ScanAsync(string path)
    {
        // Step 1: Analyze all packages in the project/solution
        var packageAnalysis = await _packageAnalyzer.AnalyzePackagesAsync(path);

        // Step 2: Check each package for vulnerabilities, outdated status, and deprecation
        var vulnerabilities = new List<PackageVulnerability>();
        var outdatedPackages = new List<OutdatedPackage>();
        var deprecatedPackages = new List<DeprecatedPackage>();
        var recommendations = new List<UpgradeRecommendation>();

        // Process packages in parallel with rate limiting
        var semaphore = new SemaphoreSlim(5); // Limit concurrent API calls
        var tasks = packageAnalysis.AllPackages.Select(async package =>
        {
            await semaphore.WaitAsync();
            try
            {
                var result = await AnalyzePackageAsync(
                    package,
                    packageAnalysis.DirectPackages,
                    packageAnalysis.TransitiveDependencyTree);

                return result;
            }
            finally
            {
                semaphore.Release();
            }
        });

        var results = await Task.WhenAll(tasks);

        // Aggregate results
        foreach (var result in results)
        {
            vulnerabilities.AddRange(result.Vulnerabilities);

            if (result.OutdatedInfo != null)
                outdatedPackages.Add(result.OutdatedInfo);

            if (result.DeprecatedInfo != null)
                deprecatedPackages.Add(result.DeprecatedInfo);

            if (result.Recommendation != null)
                recommendations.Add(result.Recommendation);
        }

        // Sort vulnerabilities by severity
        vulnerabilities = vulnerabilities
            .OrderBy(v => VulnerabilitySeverity.ToSortOrder(v.Severity))
            .ThenByDescending(v => v.CvssScore)
            .ToList();

        // Sort outdated packages by urgency
        outdatedPackages = outdatedPackages
            .OrderBy(o => VulnerabilitySeverity.ToSortOrder(o.UpdateUrgency))
            .ThenByDescending(o => o.MajorVersionsBehind)
            .ToList();

        // Sort recommendations by priority
        recommendations = recommendations
            .OrderByDescending(r => r.Priority)
            .ToList();

        // Build summary
        var summary = BuildSummary(vulnerabilities);

        return new VulnerabilityResult
        {
            TotalPackages = packageAnalysis.AllPackages.Count,
            VulnerablePackages = vulnerabilities.Select(v => v.PackageId).Distinct().Count(),
            OutdatedPackages = outdatedPackages.Count,
            DeprecatedPackages = deprecatedPackages.Count,
            Vulnerabilities = vulnerabilities,
            Outdated = outdatedPackages,
            Deprecated = deprecatedPackages,
            Recommendations = recommendations,
            TransitiveDependencyTree = packageAnalysis.TransitiveDependencyTree,
            Summary = summary
        };
    }

    private async Task<PackageAnalysisItem> AnalyzePackageAsync(
        PackageReference package,
        List<PackageReference> directPackages,
        Dictionary<string, List<string>> transitiveTree)
    {
        var result = new PackageAnalysisItem();

        try
        {
            // Get security advisories
            var advisories = await _vulnerabilityClient.GetAdvisoriesAsync(package.PackageId, package.Version);

            // Determine if this is a transitive dependency
            var isTransitive = !package.IsDirectReference;
            var transitiveSource = isTransitive
                ? _transitiveResolver.FindTransitiveSource(package.PackageId, directPackages, transitiveTree)
                : null;

            foreach (var advisory in advisories)
            {
                result.Vulnerabilities.Add(new PackageVulnerability
                {
                    PackageId = package.PackageId,
                    InstalledVersion = package.Version,
                    CveId = advisory.CveId,
                    GhsaId = advisory.GhsaId,
                    Severity = advisory.Severity,
                    CvssScore = advisory.CvssScore,
                    Description = advisory.Description,
                    FixedInVersion = advisory.FixedInVersion,
                    IsTransitive = isTransitive,
                    TransitiveSource = transitiveSource,
                    AdvisoryUrl = advisory.AdvisoryUrl,
                    PublishedDate = advisory.PublishedDate,
                    AffectedVersionRange = advisory.AffectedVersions,
                    Cwe = advisory.Cwe
                });
            }

            // Get package metadata for outdated/deprecated checks
            var metadata = await _vulnerabilityClient.GetPackageMetadataAsync(package.PackageId);

            if (metadata != null)
            {
                // Check if deprecated
                if (metadata.IsDeprecated)
                {
                    result.DeprecatedInfo = new DeprecatedPackage
                    {
                        PackageId = package.PackageId,
                        InstalledVersion = package.Version,
                        DeprecationMessage = metadata.DeprecationMessage,
                        AlternativePackage = metadata.AlternativePackage,
                        DeprecatedDate = null
                    };
                }

                // Check if outdated
                var latestVersion = metadata.LatestStableVersion ?? metadata.LatestVersion;
                if (!string.IsNullOrEmpty(latestVersion) && !IsCurrentVersion(package.Version, latestVersion))
                {
                    var (major, minor, patch) = CalculateVersionBehind(package.Version, latestVersion);
                    var urgency = CalculateUpdateUrgency(major, minor, patch, result.Vulnerabilities.Any());

                    result.OutdatedInfo = new OutdatedPackage
                    {
                        PackageId = package.PackageId,
                        InstalledVersion = package.Version,
                        LatestVersion = metadata.LatestVersion,
                        LatestStableVersion = metadata.LatestStableVersion,
                        MajorVersionsBehind = major,
                        MinorVersionsBehind = minor,
                        PatchVersionsBehind = patch,
                        IsDirectDependency = package.IsDirectReference,
                        LastUpdated = metadata.LastUpdated,
                        UpdateUrgency = urgency
                    };

                    // Generate upgrade recommendation
                    if (major > 0 || result.Vulnerabilities.Any())
                    {
                        result.Recommendation = GenerateRecommendation(
                            package,
                            latestVersion,
                            major,
                            result.Vulnerabilities);
                    }
                }
            }
        }
        catch
        {
            // Return partial results on failure
        }

        return result;
    }

    private bool IsCurrentVersion(string installed, string latest)
    {
        return CompareVersions(installed, latest) >= 0;
    }

    private (int Major, int Minor, int Patch) CalculateVersionBehind(string installed, string latest)
    {
        try
        {
            var installedParts = ParseVersion(installed);
            var latestParts = ParseVersion(latest);

            var major = Math.Max(0, latestParts.Major - installedParts.Major);
            var minor = major > 0 ? 0 : Math.Max(0, latestParts.Minor - installedParts.Minor);
            var patch = (major > 0 || minor > 0) ? 0 : Math.Max(0, latestParts.Patch - installedParts.Patch);

            return (major, minor, patch);
        }
        catch
        {
            return (0, 0, 0);
        }
    }

    private (int Major, int Minor, int Patch) ParseVersion(string version)
    {
        // Remove prerelease suffix
        var cleanVersion = version.Split('-')[0];
        var parts = cleanVersion.Split('.');

        var major = parts.Length > 0 && int.TryParse(parts[0], out var m) ? m : 0;
        var minor = parts.Length > 1 && int.TryParse(parts[1], out var mi) ? mi : 0;
        var patch = parts.Length > 2 && int.TryParse(parts[2], out var p) ? p : 0;

        return (major, minor, patch);
    }

    private int CompareVersions(string v1, string v2)
    {
        try
        {
            var v1Parts = ParseVersion(v1);
            var v2Parts = ParseVersion(v2);

            if (v1Parts.Major != v2Parts.Major)
                return v1Parts.Major.CompareTo(v2Parts.Major);
            if (v1Parts.Minor != v2Parts.Minor)
                return v1Parts.Minor.CompareTo(v2Parts.Minor);
            return v1Parts.Patch.CompareTo(v2Parts.Patch);
        }
        catch
        {
            return string.Compare(v1, v2, StringComparison.OrdinalIgnoreCase);
        }
    }

    private string CalculateUpdateUrgency(int major, int minor, int patch, bool hasVulnerabilities)
    {
        if (hasVulnerabilities)
            return VulnerabilitySeverity.Critical;

        if (major >= 2)
            return VulnerabilitySeverity.High;

        if (major >= 1)
            return VulnerabilitySeverity.Medium;

        if (minor >= 5)
            return VulnerabilitySeverity.Medium;

        return VulnerabilitySeverity.Low;
    }

    private UpgradeRecommendation GenerateRecommendation(
        PackageReference package,
        string recommendedVersion,
        int majorVersionsBehind,
        List<PackageVulnerability> vulnerabilities)
    {
        var reasons = new List<string>();
        var securityFixes = new List<string>();
        var breakingChanges = new List<string>();
        var potentialIssues = new List<string>();

        // Build reason string
        if (vulnerabilities.Any())
        {
            var criticalCount = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
            var highCount = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);

            if (criticalCount > 0)
                reasons.Add($"{criticalCount} critical vulnerabilities");
            if (highCount > 0)
                reasons.Add($"{highCount} high severity vulnerabilities");

            foreach (var vuln in vulnerabilities.Take(3))
            {
                securityFixes.Add($"{vuln.CveId ?? vuln.GhsaId ?? "Unknown"}: {vuln.Description}");
            }
        }

        if (majorVersionsBehind > 0)
        {
            reasons.Add($"{majorVersionsBehind} major version(s) behind");
            breakingChanges.Add("Major version upgrade may include breaking API changes");
            potentialIssues.Add("Review release notes before upgrading");
            potentialIssues.Add("Test thoroughly after upgrade");
        }

        var priority = CalculatePriority(vulnerabilities, majorVersionsBehind);
        var riskLevel = majorVersionsBehind > 0 ? "High" : vulnerabilities.Any() ? "Medium" : "Low";

        return new UpgradeRecommendation
        {
            PackageId = package.PackageId,
            CurrentVersion = package.Version,
            RecommendedVersion = recommendedVersion,
            Reason = string.Join("; ", reasons),
            Risk = new UpgradeRisk
            {
                Level = riskLevel,
                HasBreakingChanges = majorVersionsBehind > 0,
                RequiresCodeChanges = majorVersionsBehind > 0,
                PotentialIssues = potentialIssues
            },
            BreakingChanges = breakingChanges,
            SecurityFixes = securityFixes,
            Priority = priority
        };
    }

    private int CalculatePriority(List<PackageVulnerability> vulnerabilities, int majorVersionsBehind)
    {
        var priority = 0;

        foreach (var vuln in vulnerabilities)
        {
            priority += vuln.Severity switch
            {
                VulnerabilitySeverity.Critical => 4,
                VulnerabilitySeverity.High => 3,
                VulnerabilitySeverity.Medium => 2,
                VulnerabilitySeverity.Low => 1,
                _ => 0
            };
        }

        priority += majorVersionsBehind;

        return Math.Min(10, Math.Max(1, priority));
    }

    private VulnerabilitySummary BuildSummary(List<PackageVulnerability> vulnerabilities)
    {
        var critical = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
        var high = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
        var medium = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
        var low = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low);

        // Calculate risk score (0-100)
        var riskScore = Math.Min(100, (critical * 25) + (high * 15) + (medium * 8) + (low * 2));

        var riskLevel = riskScore switch
        {
            >= 75 => "Critical",
            >= 50 => "High",
            >= 25 => "Medium",
            >= 1 => "Low",
            _ => "Safe"
        };

        return new VulnerabilitySummary
        {
            Critical = critical,
            High = high,
            Medium = medium,
            Low = low,
            RiskScore = riskScore,
            RiskLevel = riskLevel
        };
    }

    public void Dispose()
    {
        _vulnerabilityClient.Dispose();
    }

    /// <summary>
    /// Internal class for collecting per-package analysis results.
    /// </summary>
    private class PackageAnalysisItem
    {
        public List<PackageVulnerability> Vulnerabilities { get; } = new();
        public OutdatedPackage? OutdatedInfo { get; set; }
        public DeprecatedPackage? DeprecatedInfo { get; set; }
        public UpgradeRecommendation? Recommendation { get; set; }
    }
}
