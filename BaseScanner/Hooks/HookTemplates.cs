using BaseScanner.Hooks.Models;

namespace BaseScanner.Hooks;

/// <summary>
/// Provides templates for generating Git hook scripts.
/// </summary>
public static class HookTemplates
{
    /// <summary>
    /// Marker comment to identify BaseScanner-generated hooks.
    /// </summary>
    public const string BaseScannerMarker = "# Generated by BaseScanner - DO NOT EDIT MANUALLY";

    /// <summary>
    /// Gets the pre-commit hook template for Bash.
    /// </summary>
    public static string GetPreCommitBashTemplate(HookConfiguration config)
    {
        var failOn = string.Join(",", config.FailOn.Select(s => s.ToString().ToLowerInvariant()));
        var analyses = GetAnalysisFlags(config.Analyses);
        var incrementalFlag = config.Incremental ? "--incremental" : "";
        var quickFlag = config.Quick ? "--quick" : "";
        var excludePatterns = string.Join("|", config.ExcludePatterns.Select(EscapeRegexPattern));
        var customArgs = config.CustomArgs ?? "";

        return $@"#!/bin/bash
{BaseScannerMarker}
# Pre-commit hook for BaseScanner code analysis
# Timeout: {config.TimeoutSeconds} seconds

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e ""${{YELLOW}}Running BaseScanner pre-commit analysis...${{NC}}""

# Get staged C# files
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$' | grep -vE '{excludePatterns}' || true)

if [ -z ""$CHANGED_FILES"" ]; then
    echo -e ""${{GREEN}}No C# files staged for commit. Skipping analysis.${{NC}}""
    exit 0
fi

echo ""Analyzing files:""
echo ""$CHANGED_FILES"" | while read file; do echo ""  - $file""; done

# Run BaseScanner with timeout
if timeout {config.TimeoutSeconds} basescanner . {incrementalFlag} {quickFlag} {analyses} --files=""$CHANGED_FILES"" --fail-on={failOn} {customArgs}; then
    echo -e ""${{GREEN}}BaseScanner analysis passed!${{NC}}""
    exit 0
else
    EXIT_CODE=$?
    if [ $EXIT_CODE -eq 124 ]; then
        echo -e ""${{YELLOW}}BaseScanner analysis timed out after {config.TimeoutSeconds} seconds.${{NC}}""
        echo -e ""${{YELLOW}}Consider increasing timeout or running with --quick flag.${{NC}}""
        exit 1
    else
        echo -e ""${{RED}}BaseScanner found issues. Please fix them before committing.${{NC}}""
        exit $EXIT_CODE
    fi
fi
";
    }

    /// <summary>
    /// Gets the pre-commit hook template for PowerShell.
    /// </summary>
    public static string GetPreCommitPowerShellTemplate(HookConfiguration config)
    {
        var failOn = string.Join(",", config.FailOn.Select(s => s.ToString().ToLowerInvariant()));
        var analyses = GetAnalysisFlags(config.Analyses);
        var incrementalFlag = config.Incremental ? "--incremental" : "";
        var quickFlag = config.Quick ? "--quick" : "";
        var excludePatterns = string.Join("|", config.ExcludePatterns.Select(EscapeRegexPattern));
        var customArgs = config.CustomArgs ?? "";

        return $@"{BaseScannerMarker}
# Pre-commit hook for BaseScanner code analysis
# Timeout: {config.TimeoutSeconds} seconds

$ErrorActionPreference = ""Stop""

function Write-ColorOutput {{
    param([string]$Message, [string]$Color = ""White"")
    Write-Host $Message -ForegroundColor $Color
}}

Write-ColorOutput ""Running BaseScanner pre-commit analysis..."" ""Yellow""

# Get staged C# files
$files = git diff --cached --name-only --diff-filter=ACM |
    Where-Object {{ $_ -match '\.cs$' }} |
    Where-Object {{ $_ -notmatch '{excludePatterns}' }}

if (-not $files -or $files.Count -eq 0) {{
    Write-ColorOutput ""No C# files staged for commit. Skipping analysis."" ""Green""
    exit 0
}}

Write-ColorOutput ""Analyzing files:"" ""White""
$files | ForEach-Object {{ Write-ColorOutput ""  - $_"" ""White"" }}

$fileList = $files -join ','

# Run BaseScanner with timeout
$job = Start-Job -ScriptBlock {{
    param($Path, $Files, $Args)
    Set-Location $Path
    & basescanner . {incrementalFlag} {quickFlag} {analyses} --files=""$Files"" --fail-on={failOn} {customArgs}
}} -ArgumentList (Get-Location).Path, $fileList, $null

$completed = Wait-Job $job -Timeout {config.TimeoutSeconds}

if (-not $completed) {{
    Stop-Job $job
    Remove-Job $job -Force
    Write-ColorOutput ""BaseScanner analysis timed out after {config.TimeoutSeconds} seconds."" ""Yellow""
    Write-ColorOutput ""Consider increasing timeout or running with --quick flag."" ""Yellow""
    exit 1
}}

$result = Receive-Job $job
$exitCode = $job.State -eq 'Completed' ? 0 : 1
Remove-Job $job

if ($exitCode -eq 0) {{
    Write-ColorOutput ""BaseScanner analysis passed!"" ""Green""
    exit 0
}} else {{
    Write-ColorOutput ""BaseScanner found issues. Please fix them before committing."" ""Red""
    exit $exitCode
}}
";
    }

    /// <summary>
    /// Gets the pre-push hook template for Bash.
    /// </summary>
    public static string GetPrePushBashTemplate(HookConfiguration config)
    {
        var failOn = string.Join(",", config.FailOn.Select(s => s.ToString().ToLowerInvariant()));
        var analyses = GetAnalysisFlags(config.Analyses);
        var incrementalFlag = config.Incremental ? "--incremental" : "";
        var excludePatterns = string.Join("|", config.ExcludePatterns.Select(EscapeRegexPattern));
        var customArgs = config.CustomArgs ?? "";

        return $@"#!/bin/bash
{BaseScannerMarker}
# Pre-push hook for BaseScanner code analysis
# Timeout: {config.TimeoutSeconds} seconds

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Read push information from stdin
while read local_ref local_sha remote_ref remote_sha
do
    if [ ""$local_sha"" = ""0000000000000000000000000000000000000000"" ]; then
        # Branch deletion, skip
        continue
    fi

    if [ ""$remote_sha"" = ""0000000000000000000000000000000000000000"" ]; then
        # New branch, check all files
        RANGE=""$local_sha""
    else
        # Existing branch, check changed files
        RANGE=""$remote_sha..$local_sha""
    fi

    echo -e ""${{YELLOW}}Running BaseScanner pre-push analysis for $local_ref...${{NC}}""

    # Get changed C# files
    CHANGED_FILES=$(git diff --name-only $RANGE -- '*.cs' | grep -vE '{excludePatterns}' || true)

    if [ -z ""$CHANGED_FILES"" ]; then
        echo -e ""${{GREEN}}No C# files changed. Skipping analysis.${{NC}}""
        continue
    fi

    echo ""Analyzing files:""
    echo ""$CHANGED_FILES"" | while read file; do echo ""  - $file""; done

    # Run BaseScanner with full analysis
    if timeout {config.TimeoutSeconds} basescanner . {incrementalFlag} {analyses} --files=""$CHANGED_FILES"" --fail-on={failOn} {customArgs}; then
        echo -e ""${{GREEN}}BaseScanner analysis passed!${{NC}}""
    else
        EXIT_CODE=$?
        if [ $EXIT_CODE -eq 124 ]; then
            echo -e ""${{YELLOW}}BaseScanner analysis timed out after {config.TimeoutSeconds} seconds.${{NC}}""
            exit 1
        else
            echo -e ""${{RED}}BaseScanner found issues. Please fix them before pushing.${{NC}}""
            exit $EXIT_CODE
        fi
    fi
done

exit 0
";
    }

    /// <summary>
    /// Gets the pre-push hook template for PowerShell.
    /// </summary>
    public static string GetPrePushPowerShellTemplate(HookConfiguration config)
    {
        var failOn = string.Join(",", config.FailOn.Select(s => s.ToString().ToLowerInvariant()));
        var analyses = GetAnalysisFlags(config.Analyses);
        var incrementalFlag = config.Incremental ? "--incremental" : "";
        var excludePatterns = string.Join("|", config.ExcludePatterns.Select(EscapeRegexPattern));
        var customArgs = config.CustomArgs ?? "";

        return $@"{BaseScannerMarker}
# Pre-push hook for BaseScanner code analysis
# Timeout: {config.TimeoutSeconds} seconds

$ErrorActionPreference = ""Stop""

function Write-ColorOutput {{
    param([string]$Message, [string]$Color = ""White"")
    Write-Host $Message -ForegroundColor $Color
}}

# Read push information from stdin
$input | ForEach-Object {{
    $parts = $_ -split '\s+'
    $localRef = $parts[0]
    $localSha = $parts[1]
    $remoteSha = $parts[3]

    if ($localSha -eq ""0000000000000000000000000000000000000000"") {{
        # Branch deletion, skip
        return
    }}

    if ($remoteSha -eq ""0000000000000000000000000000000000000000"") {{
        # New branch
        $range = $localSha
    }} else {{
        # Existing branch
        $range = ""$remoteSha..$localSha""
    }}

    Write-ColorOutput ""Running BaseScanner pre-push analysis for $localRef..."" ""Yellow""

    # Get changed C# files
    $files = git diff --name-only $range -- '*.cs' |
        Where-Object {{ $_ -notmatch '{excludePatterns}' }}

    if (-not $files -or $files.Count -eq 0) {{
        Write-ColorOutput ""No C# files changed. Skipping analysis."" ""Green""
        return
    }}

    Write-ColorOutput ""Analyzing files:"" ""White""
    $files | ForEach-Object {{ Write-ColorOutput ""  - $_"" ""White"" }}

    $fileList = $files -join ','

    # Run BaseScanner
    $job = Start-Job -ScriptBlock {{
        param($Path, $Files)
        Set-Location $Path
        & basescanner . {incrementalFlag} {analyses} --files=""$Files"" --fail-on={failOn} {customArgs}
    }} -ArgumentList (Get-Location).Path, $fileList

    $completed = Wait-Job $job -Timeout {config.TimeoutSeconds}

    if (-not $completed) {{
        Stop-Job $job
        Remove-Job $job -Force
        Write-ColorOutput ""BaseScanner analysis timed out after {config.TimeoutSeconds} seconds."" ""Yellow""
        exit 1
    }}

    $result = Receive-Job $job
    $exitCode = $job.State -eq 'Completed' ? 0 : 1
    Remove-Job $job

    if ($exitCode -ne 0) {{
        Write-ColorOutput ""BaseScanner found issues. Please fix them before pushing."" ""Red""
        exit $exitCode
    }}

    Write-ColorOutput ""BaseScanner analysis passed!"" ""Green""
}}

exit 0
";
    }

    /// <summary>
    /// Gets the commit-msg hook template for Bash.
    /// </summary>
    public static string GetCommitMsgBashTemplate(HookConfiguration config)
    {
        return $@"#!/bin/bash
{BaseScannerMarker}
# Commit message validation hook

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat ""$COMMIT_MSG_FILE"")

# Minimum length check
if [ ${{#COMMIT_MSG}} -lt 10 ]; then
    echo ""Error: Commit message must be at least 10 characters long.""
    exit 1
fi

# Check for conventional commit format (optional)
if ! echo ""$COMMIT_MSG"" | grep -qE ""^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+""; then
    echo ""Warning: Consider using conventional commit format:""
    echo ""  <type>(<scope>): <description>""
    echo ""  Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert""
fi

exit 0
";
    }

    /// <summary>
    /// Gets the commit-msg hook template for PowerShell.
    /// </summary>
    public static string GetCommitMsgPowerShellTemplate(HookConfiguration config)
    {
        return $@"{BaseScannerMarker}
# Commit message validation hook

param([string]$CommitMsgFile)

$commitMsg = Get-Content $CommitMsgFile -Raw

# Minimum length check
if ($commitMsg.Length -lt 10) {{
    Write-Host ""Error: Commit message must be at least 10 characters long."" -ForegroundColor Red
    exit 1
}}

# Check for conventional commit format (optional)
if ($commitMsg -notmatch ""^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+"") {{
    Write-Host ""Warning: Consider using conventional commit format:"" -ForegroundColor Yellow
    Write-Host ""  <type>(<scope>): <description>"" -ForegroundColor Yellow
    Write-Host ""  Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"" -ForegroundColor Yellow
}}

exit 0
";
    }

    /// <summary>
    /// Gets a wrapper script that invokes PowerShell from a bash-style hook.
    /// This is needed because Git on Windows uses bash for hooks by default.
    /// </summary>
    public static string GetPowerShellWrapperBashTemplate(HookType hookType)
    {
        var psScriptName = hookType switch
        {
            HookType.PreCommit => "pre-commit.ps1",
            HookType.PrePush => "pre-push.ps1",
            HookType.CommitMsg => "commit-msg.ps1",
            _ => $"{hookType.ToString().ToLowerInvariant()}.ps1"
        };

        return $@"#!/bin/bash
{BaseScannerMarker}
# PowerShell wrapper for {hookType} hook

HOOK_DIR=""$(dirname ""$0"")""
POWERSHELL_SCRIPT=""$HOOK_DIR/{psScriptName}""

if [ ! -f ""$POWERSHELL_SCRIPT"" ]; then
    echo ""Error: PowerShell hook script not found: $POWERSHELL_SCRIPT""
    exit 1
fi

# Try PowerShell Core first, then Windows PowerShell
if command -v pwsh &> /dev/null; then
    pwsh -NoProfile -ExecutionPolicy Bypass -File ""$POWERSHELL_SCRIPT"" ""$@""
elif command -v powershell &> /dev/null; then
    powershell -NoProfile -ExecutionPolicy Bypass -File ""$POWERSHELL_SCRIPT"" ""$@""
else
    echo ""Error: PowerShell not found. Please install PowerShell.""
    exit 1
fi

exit $?
";
    }

    /// <summary>
    /// Gets a hook script for the specified type and shell.
    /// </summary>
    public static string GetHookTemplate(HookType hookType, ShellType shellType, HookConfiguration config)
    {
        return (hookType, shellType) switch
        {
            (HookType.PreCommit, ShellType.Bash) => GetPreCommitBashTemplate(config),
            (HookType.PreCommit, ShellType.PowerShell) => GetPreCommitPowerShellTemplate(config),
            (HookType.PrePush, ShellType.Bash) => GetPrePushBashTemplate(config),
            (HookType.PrePush, ShellType.PowerShell) => GetPrePushPowerShellTemplate(config),
            (HookType.CommitMsg, ShellType.Bash) => GetCommitMsgBashTemplate(config),
            (HookType.CommitMsg, ShellType.PowerShell) => GetCommitMsgPowerShellTemplate(config),
            _ => throw new NotSupportedException($"Hook template for {hookType} with {shellType} is not supported.")
        };
    }

    /// <summary>
    /// Converts analysis flags to CLI arguments.
    /// </summary>
    private static string GetAnalysisFlags(HookAnalysisType analyses)
    {
        if (analyses == HookAnalysisType.All)
            return "--all";

        var flags = new List<string>();

        if (analyses.HasFlag(HookAnalysisType.Security)) flags.Add("--security");
        if (analyses.HasFlag(HookAnalysisType.Performance)) flags.Add("--perf");
        if (analyses.HasFlag(HookAnalysisType.Exceptions)) flags.Add("--exceptions");
        if (analyses.HasFlag(HookAnalysisType.Resources)) flags.Add("--resources");
        if (analyses.HasFlag(HookAnalysisType.Dependencies)) flags.Add("--deps");
        if (analyses.HasFlag(HookAnalysisType.Magic)) flags.Add("--magic");
        if (analyses.HasFlag(HookAnalysisType.Refactoring)) flags.Add("--refactor");
        if (analyses.HasFlag(HookAnalysisType.Architecture)) flags.Add("--arch");
        if (analyses.HasFlag(HookAnalysisType.Safety)) flags.Add("--safety");

        return string.Join(" ", flags);
    }

    /// <summary>
    /// Escapes special regex characters in a glob pattern.
    /// </summary>
    private static string EscapeRegexPattern(string pattern)
    {
        return pattern
            .Replace(".", "\\.")
            .Replace("**/", "(.*/)?")
            .Replace("**", ".*")
            .Replace("*", "[^/]*")
            .Replace("?", ".");
    }
}
